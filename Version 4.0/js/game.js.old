// Game State and Config are now in state.js

// Email validation function
function validateEmail(email) {
    // RFC 5322 compliant email regex
    const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    return emailRegex.test(email);
}

// Password validation function
function validatePasswordStrength() {
    const password = document.getElementById('signupPassword').value;
    const requirementsDiv = document.getElementById('passwordRequirements');

    // Show requirements when user starts typing
    if (password.length > 0) {
        requirementsDiv.style.display = 'block';
    } else {
        requirementsDiv.style.display = 'none';
        return;
    }

    // Check each requirement
    const requirements = {
        length: password.length >= 12,
        uppercase: /[A-Z]/.test(password),
        lowercase: /[a-z]/.test(password),
        number: /[0-9]/.test(password),
        symbol: /[!@#$%&*]/.test(password)
    };

    // Update UI for each requirement
    updateRequirement('req-length', requirements.length);
    updateRequirement('req-uppercase', requirements.uppercase);
    updateRequirement('req-lowercase', requirements.lowercase);
    updateRequirement('req-number', requirements.number);
    updateRequirement('req-symbol', requirements.symbol);

    return requirements;
}

function updateRequirement(elementId, isValid) {
    const element = document.getElementById(elementId);
    if (!element) return;

    const icon = element.querySelector('.req-icon');

    if (isValid) {
        element.classList.add('valid');
        icon.textContent = '‚úì';
    } else {
        element.classList.remove('valid');
        icon.textContent = '‚úó';
    }
}

function checkPasswordStrength(password) {
    const requirements = {
        length: password.length >= 12,
        uppercase: /[A-Z]/.test(password),
        lowercase: /[a-z]/.test(password),
        number: /[0-9]/.test(password),
        symbol: /[!@#$%&*]/.test(password)
    };

    return Object.values(requirements).every(req => req === true);
}

// Auth UI functions are in main-menu-functions.js

async function signup() {
    const username = document.getElementById('signupUsername').value.trim();
    const email = document.getElementById('signupEmail').value.trim();
    const password = document.getElementById('signupPassword').value;
    const passwordConfirm = document.getElementById('signupPasswordConfirm').value;

    if (!username || !email || !password) {
        document.getElementById('authMessage').textContent = 'Please fill all fields';
        document.getElementById('authMessage').className = 'text-red-400 text-xs mt-4 text-center';
        return;
    }

    // Validate email format
    if (!validateEmail(email)) {
        document.getElementById('authMessage').textContent = 'Please enter a valid email address';
        document.getElementById('authMessage').className = 'text-red-400 text-xs mt-4 text-center';
        return;
    }

    // Validate password strength
    if (!checkPasswordStrength(password)) {
        document.getElementById('authMessage').textContent = 'Password does not meet all requirements';
        document.getElementById('authMessage').className = 'text-red-400 text-xs mt-4 text-center';
        return;
    }

    if (password !== passwordConfirm) {
        document.getElementById('authMessage').textContent = 'Passwords do not match';
        document.getElementById('authMessage').className = 'text-red-400 text-xs mt-4 text-center';
        return;
    }

    try {
        // Create Firebase user
        const userCredential = await auth.createUserWithEmailAndPassword(email, password);
        const user = userCredential.user;

        // Create user document in Firestore
        await db.collection('users').doc(user.uid).set({
            username: username,
            email: email,
            character: null,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        // Send email verification
        await user.sendEmailVerification();

        document.getElementById('authMessage').textContent = 'Account created! Verification email sent.';
        document.getElementById('authMessage').className = 'text-green-400 text-xs mt-4 text-center';

        setTimeout(() => {
            showLogin();
            document.getElementById('loginEmail').value = email;
        }, 2000);
    } catch (error) {
        console.error('Signup error:', error);
        let errorMessage = 'Signup failed';

        if (error.code === 'auth/email-already-in-use') {
            errorMessage = 'Email already in use';
        } else if (error.code === 'auth/invalid-email') {
            errorMessage = 'Invalid email address';
        } else if (error.code === 'auth/weak-password') {
            errorMessage = 'Password is too weak';
        }

        document.getElementById('authMessage').textContent = errorMessage;
        document.getElementById('authMessage').className = 'text-red-400 text-xs mt-4 text-center';
    }
}

async function login() {
    const email = document.getElementById('loginEmail').value.trim();
    const password = document.getElementById('loginPassword').value;

    if (!email || !password) {
        document.getElementById('authMessage').textContent = 'Please fill all fields';
        document.getElementById('authMessage').className = 'text-red-400 text-xs mt-4 text-center';
        return;
    }

    try {
        // Sign in with Firebase
        const userCredential = await auth.signInWithEmailAndPassword(email, password);
        const user = userCredential.user;

        // Get user data from Firestore
        const userDoc = await db.collection('users').doc(user.uid).get();

        if (userDoc.exists) {
            const userData = userDoc.data();
            gameState.currentUser = userData.username;
            gameState.currentUserId = user.uid;
            localStorage.setItem('currentUserId', user.uid);

            if (userData.character) {
                gameState.character = userData.character;
                await loadProgress();
                showGameScreen();
            } else {
                showCharacterSelection();
            }
        } else {
            document.getElementById('authMessage').textContent = 'User data not found';
            document.getElementById('authMessage').className = 'text-red-400 text-xs mt-4 text-center';
        }
    } catch (error) {
        console.error('Login error:', error);
        let errorMessage = 'Invalid credentials';

        if (error.code === 'auth/user-not-found') {
            errorMessage = 'No account found with this email';
        } else if (error.code === 'auth/wrong-password') {
            errorMessage = 'Incorrect password';
        } else if (error.code === 'auth/invalid-email') {
            errorMessage = 'Invalid email address';
        } else if (error.code === 'auth/user-disabled') {
            errorMessage = 'Account has been disabled';
        }

        document.getElementById('authMessage').textContent = errorMessage;
        document.getElementById('authMessage').className = 'text-red-400 text-xs mt-4 text-center';
    }
}

async function logout() {
    await saveProgress();

    try {
        await auth.signOut();
    } catch (error) {
        console.error('Logout error:', error);
    }

    localStorage.removeItem('currentUserId');
    location.reload();
}

// Forgot Password function
async function forgotPassword() {
    const email = prompt('Enter your email address:');
    if (!email) return;

    try {
        await auth.sendPasswordResetEmail(email);
        alert('Password reset email sent! Please check your inbox.');
    } catch (error) {
        console.error('Password reset error:', error);
        let errorMessage = 'Failed to send reset email';

        if (error.code === 'auth/user-not-found') {
            errorMessage = 'No account found with this email';
        } else if (error.code === 'auth/invalid-email') {
            errorMessage = 'Invalid email address';
        }

        alert(errorMessage);
    }
}

async function loadUserSession() {
    // Listen for auth state changes
    auth.onAuthStateChanged(async (user) => {
        if (user) {
            gameState.currentUserId = user.uid;

            try {
                const userDoc = await db.collection('users').doc(user.uid).get();

                if (userDoc.exists) {
                    const userData = userDoc.data();
                    gameState.currentUser = userData.username;

                    if (userData.character) {
                        gameState.character = userData.character;
                        await loadProgress();
                        showGameScreen();
                    } else {
                        showCharacterSelection();
                    }
                }
            } catch (error) {
                console.error('Session load error:', error);
            }
        }
    });
}

// Character Selection
function showCharacterSelection() {
    document.getElementById('authScreen').style.display = 'none';
    document.getElementById('characterScreen').style.display = 'block';
}

function selectCharacter(type) {
    document.querySelectorAll('.character-option').forEach(el => el.classList.remove('selected'));
    document.getElementById(type + 'Char').classList.add('selected');
    gameState.character = type;
    document.getElementById('startGameBtn').disabled = false;
}

async function startGame() {
    if (!gameState.character || !gameState.currentUserId) return;

    try {
        // Save character to Firestore
        await db.collection('users').doc(gameState.currentUserId).update({
            character: gameState.character
        });

        showGameScreen();
    } catch (error) {
        console.error('Set character error:', error);
        showGameScreen(); // Continue anyway
    }
}

function showGameScreen() {
    document.getElementById('authScreen').style.display = 'none';
    document.getElementById('characterScreen').style.display = 'none';
    document.getElementById('gameScreen').style.display = 'block';

    document.getElementById('playerName').textContent = gameState.currentUser;

    initLevel();
    updateUI();

    // Keyboard controls
    document.addEventListener('keydown', handleKeyPress);
}

// Game Logic
function initLevel() {
    const config = getLevelConfig(gameState.currentLevel);

    // Reset door state
    gameState.doorUnlocked = false;

    // Generate chest positions with safety limit
    gameState.chests = [];
    const maxAttempts = 100; // Prevent infinite loops

    for (let i = 0; i < config.chestCount; i++) {
        let attempts = 0;
        let pos;

        do {
            pos = {
                x: Math.floor(Math.random() * (GRID_SIZE - 4)) + 2,
                y: Math.floor(Math.random() * (GRID_SIZE - 4)) + 2,
                opened: false
            };
            attempts++;

            if (attempts > maxAttempts) {
                console.error('Could not place chest', i);
                break;
            }
        } while (isPositionOccupied(pos) && attempts < maxAttempts);

        if (attempts < maxAttempts) {
            gameState.chests.push(pos);
        }
    }

    // Generate door position with safety limit
    let doorAttempts = 0;
    do {
        gameState.doorPos = {
            x: Math.floor(Math.random() * (GRID_SIZE - 4)) + 2,
            y: Math.floor(Math.random() * (GRID_SIZE - 4)) + 2
        };
        doorAttempts++;

        if (doorAttempts > maxAttempts) {
            // Fallback position
            gameState.doorPos = { x: GRID_SIZE - 2, y: GRID_SIZE - 2 };
            break;
        }
    } while (isPositionOccupied(gameState.doorPos) && doorAttempts < maxAttempts);

    // Reset player position
    gameState.playerPos = { x: 1, y: 1 };

    renderDungeon();
}

function isPositionOccupied(pos) {
    if (pos.x === gameState.playerPos.x && pos.y === gameState.playerPos.y) return true;
    if (gameState.doorPos && pos.x === gameState.doorPos.x && pos.y === gameState.doorPos.y) return true;
    for (let chest of gameState.chests) {
        if (chest.x === pos.x && chest.y === pos.y) return true;
    }
    return false;
}

function renderDungeon() {
    const grid = document.getElementById('dungeonGrid');
    grid.innerHTML = '';
    grid.style.gridTemplateColumns = `repeat(${GRID_SIZE}, 40px)`;
    grid.style.gridTemplateRows = `repeat(${GRID_SIZE}, 40px)`;

    for (let y = 0; y < GRID_SIZE; y++) {
        for (let x = 0; x < GRID_SIZE; x++) {
            const cell = document.createElement('div');
            cell.className = 'cell';

            // Walls on edges
            if (x === 0 || x === GRID_SIZE - 1 || y === 0 || y === GRID_SIZE - 1) {
                cell.classList.add('wall');
            } else {
                cell.classList.add('floor');
            }

            // Player
            if (x === gameState.playerPos.x && y === gameState.playerPos.y) {
                const player = document.createElement('div');
                player.className = 'player';
                player.textContent = gameState.character === 'male' ? 'üßô‚Äç‚ôÇÔ∏è' : 'üßô‚Äç‚ôÄÔ∏è';
                player.style.fontSize = '28px';
                cell.appendChild(player);
            }

            // Chests
            gameState.chests.forEach(chest => {
                if (chest.x === x && chest.y === y) {
                    const chestEl = document.createElement('div');
                    chestEl.className = 'chest';
                    if (chest.opened) {
                        chestEl.classList.add('chest-open');
                        const tick = document.createElement('div');
                        tick.className = 'chest-tick';
                        tick.textContent = '‚úì';
                        cell.appendChild(tick);
                    }
                    cell.appendChild(chestEl);
                }
            });

            // Door
            if (gameState.doorPos && gameState.doorPos.x === x && gameState.doorPos.y === y) {
                const door = document.createElement('div');
                door.className = 'door';
                if (!gameState.doorUnlocked) {
                    door.classList.add('door-locked');
                }
                cell.appendChild(door);
            }

            grid.appendChild(cell);
        }
    }
}

function handleKeyPress(e) {
    if (document.querySelector('.modal.active')) return;

    let newX = gameState.playerPos.x;
    let newY = gameState.playerPos.y;

    switch (e.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
            newY--;
            break;
        case 'ArrowDown':
        case 's':
        case 'S':
            newY++;
            break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
            newX--;
            break;
        case 'ArrowRight':
        case 'd':
        case 'D':
            newX++;
            break;
        default:
            return;
    }

    e.preventDefault();

    // Check boundaries
    if (newX <= 0 || newX >= GRID_SIZE - 1 || newY <= 0 || newY >= GRID_SIZE - 1) {
        return;
    }

    // Check chest collision
    for (let i = 0; i < gameState.chests.length; i++) {
        const chest = gameState.chests[i];
        if (chest.x === newX && chest.y === newY) {
            if (!chest.opened) {
                openChest(i);
            }
            return;
        }
    }

    // Check door collision
    if (gameState.doorPos && gameState.doorPos.x === newX && gameState.doorPos.y === newY) {
        if (gameState.doorUnlocked) {
            nextLevel();
        }
        return;
    }

    // Move player
    gameState.playerPos.x = newX;
    gameState.playerPos.y = newY;
    renderDungeon();
}

function openChest(index) {
    gameState.currentChestIndex = index;
    generatePuzzle();
    document.getElementById('puzzleModal').classList.add('active');
    document.getElementById('puzzleAnswer').value = '';
    document.getElementById('puzzleAnswer').focus();
}

async function generatePuzzle() {
    // Show loading spinner
    document.getElementById('puzzleLoading').style.display = 'block';
    document.getElementById('puzzleImage').style.display = 'none';
    document.getElementById('puzzleQuestion').textContent = 'Loading puzzle...';

    try {
        // Call Banana API through PHP proxy (bypasses CORS)
        const response = await fetch(API_BASE_URL + 'banana_api.php');
        const data = await response.json();

        // Check if it's a fallback puzzle
        if (data.fallback) {
            // Use fallback math puzzle
            const operations = ['+', '-', '*'];
            const num1 = Math.floor(Math.random() * 20) + 1;
            const num2 = Math.floor(Math.random() * 20) + 1;
            const operation = operations[Math.floor(Math.random() * operations.length)];

            let answer;
            switch (operation) {
                case '+':
                    answer = num1 + num2;
                    break;
                case '-':
                    answer = num1 - num2;
                    break;
                case '*':
                    answer = num1 * num2;
                    break;
            }

            gameState.currentPuzzle = {
                question: `What is ${num1} ${operation} ${num2}?`,
                answer: answer.toString()
            };

            document.getElementById('puzzleLoading').style.display = 'none';
            document.getElementById('puzzleImage').style.display = 'none';
            document.getElementById('puzzleQuestion').textContent = gameState.currentPuzzle.question;
        } else {
            // Banana API success - Store puzzle data
            gameState.currentPuzzle = {
                question: data.question,
                answer: data.solution.toString(),
                imageUrl: data.question
            };

            // Display the puzzle image
            const puzzleImage = document.getElementById('puzzleImage');
            puzzleImage.src = data.question;
            puzzleImage.onload = () => {
                document.getElementById('puzzleLoading').style.display = 'none';
                puzzleImage.style.display = 'block';
            };
            puzzleImage.onerror = () => {
                // Image failed to load, show fallback
                document.getElementById('puzzleLoading').style.display = 'none';
                document.getElementById('puzzleImage').style.display = 'none';
                document.getElementById('puzzleQuestion').textContent = 'Error loading puzzle. Try again!';
            };

            document.getElementById('puzzleQuestion').textContent = 'What number do you see?';
        }

    } catch (error) {
        console.error('Banana API error:', error);
        // Fallback to math puzzle
        const operations = ['+', '-', '*'];
        const num1 = Math.floor(Math.random() * 20) + 1;
        const num2 = Math.floor(Math.random() * 20) + 1;
        const operation = operations[Math.floor(Math.random() * operations.length)];

        let answer;
        switch (operation) {
            case '+':
                answer = num1 + num2;
                break;
            case '-':
                answer = num1 - num2;
                break;
            case '*':
                answer = num1 * num2;
                break;
        }

        gameState.currentPuzzle = {
            question: `What is ${num1} ${operation} ${num2}?`,
            answer: answer.toString()
        };

        document.getElementById('puzzleLoading').style.display = 'none';
        document.getElementById('puzzleImage').style.display = 'none';
        document.getElementById('puzzleQuestion').textContent = gameState.currentPuzzle.question;
    }
}

async function submitPuzzle() {
    const answer = document.getElementById('puzzleAnswer').value.trim();

    if (answer === gameState.currentPuzzle.answer) {
        // Correct answer
        gameState.chests[gameState.currentChestIndex].opened = true;
        gameState.xp += 50;

        // Check level up
        const xpForNextLevel = gameState.playerLevel * 100;
        if (gameState.xp >= xpForNextLevel) {
            gameState.xp -= xpForNextLevel;
            gameState.playerLevel++;
        }

        // Check if all chests are opened
        if (gameState.chests.every(chest => chest.opened)) {
            gameState.doorUnlocked = true;
        }

        closePuzzle();
        document.getElementById('victoryModal').classList.add('active');
        renderDungeon();
        updateUI();
        await saveProgress();
    } else {
        // Wrong answer
        gameState.hearts--;
        closePuzzle();

        document.getElementById('correctAnswer').textContent = gameState.currentPuzzle.answer;
        document.getElementById('deathModal').classList.add('active');

        updateUI();
        await saveProgress();

        if (gameState.hearts <= 0) {
            setTimeout(() => {
                closeDeath();
                gameOver();
            }, 2000);
        }
    }
}

function closePuzzle() {
    document.getElementById('puzzleModal').classList.remove('active');
}

function closeVictory() {
    document.getElementById('victoryModal').classList.remove('active');
}

function closeDeath() {
    document.getElementById('deathModal').classList.remove('active');
}

async function nextLevel() {
    gameState.currentLevel++;
    gameState.hearts = gameState.maxHearts; // Restore hearts

    // Show level transition
    showLevelTransition(gameState.currentLevel);

    // Wait a bit before initializing new level
    setTimeout(() => {
        initLevel();
        updateUI();
    }, 500);

    await saveProgress();
}

function gameOver() {
    document.getElementById('finalLevel').textContent = gameState.currentLevel;
    document.getElementById('gameOverModal').classList.add('active');
    saveProgress();
}

async function restartGame() {
    gameState.hearts = gameState.maxHearts;
    gameState.currentLevel = 1;
    gameState.xp = 0;
    gameState.playerLevel = 1;

    document.getElementById('gameOverModal').classList.remove('active');
    initLevel();
    updateUI();
    await saveProgress();
}

function updateUI() {
    // Hearts
    let heartsHTML = '';
    for (let i = 0; i < gameState.maxHearts; i++) {
        if (i < gameState.hearts) {
            heartsHTML += '<span class="heart">‚ù§Ô∏è</span>';
        } else {
            heartsHTML += '<span class="heart" style="opacity:0.3">üñ§</span>';
        }
    }
    document.getElementById('hearts').innerHTML = heartsHTML;

    // Level and XP
    document.getElementById('currentLevel').textContent = gameState.currentLevel;
    document.getElementById('xpDisplay').textContent = gameState.xp;
    document.getElementById('playerLevel').textContent = gameState.playerLevel;

    // XP Progress Bar
    const xpForNextLevel = gameState.playerLevel * 100;
    const xpProgress = (gameState.xp / xpForNextLevel) * 100;
    document.getElementById('xpBar').style.width = xpProgress + '%';
    document.getElementById('xpToNext').textContent = xpForNextLevel - gameState.xp;
}

// Save/Load Progress with Firestore - INCLUDES CHEST STATES
async function saveProgress() {
    if (!gameState.currentUserId) return;

    const progressData = {
        hearts: gameState.hearts,
        xp: gameState.xp,
        playerLevel: gameState.playerLevel,
        currentLevel: gameState.currentLevel,
        character: gameState.character,
        chests: gameState.chests,  // SAVE CHEST STATES
        doorUnlocked: gameState.doorUnlocked,
        playerPos: gameState.playerPos,
        doorPos: gameState.doorPos,
        lastSaved: firebase.firestore.FieldValue.serverTimestamp()
    };

    try {
        await db.collection('userProgress').doc(gameState.currentUserId).set(progressData);

        // Update leaderboard
        const totalXp = (gameState.playerLevel - 1) * 100 + gameState.xp;
        await db.collection('leaderboard').doc(gameState.currentUserId).set({
            username: gameState.currentUser,
            highestLevel: gameState.currentLevel,
            totalXp: totalXp,
            playerLevel: gameState.playerLevel,
            updatedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
    } catch (error) {
        console.error('Save progress error:', error);
    }
}

async function loadProgress() {
    if (!gameState.currentUserId) return;

    try {
        const doc = await db.collection('userProgress').doc(gameState.currentUserId).get();

        if (doc.exists) {
            const data = doc.data();
            gameState.hearts = data.hearts || 3;
            gameState.xp = data.xp || 0;
            gameState.playerLevel = data.playerLevel || 1;
            gameState.currentLevel = data.currentLevel || 1;
            gameState.chests = data.chests || [];  // LOAD CHEST STATES
            gameState.doorUnlocked = data.doorUnlocked || false;
            gameState.playerPos = data.playerPos || { x: 1, y: 1 };
            gameState.doorPos = data.doorPos || null;
        }
    } catch (error) {
        console.error('Load progress error:', error);
    }
}

// Leaderboard with Firestore
async function showLeaderboard() {
    await updateLeaderboard();
    document.getElementById('leaderboardModal').classList.add('active');
}

function closeLeaderboard() {
    document.getElementById('leaderboardModal').classList.remove('active');
}

async function updateLeaderboard() {
    try {
        // Get top 10 by highest level
        const levelSnapshot = await db.collection('leaderboard')
            .orderBy('highestLevel', 'desc')
            .orderBy('totalXp', 'desc')
            .limit(10)
            .get();

        let levelHTML = '';
        levelSnapshot.forEach((doc, index) => {
            const player = doc.data();
            levelHTML += `
                <tr style="${player.username === gameState.currentUser ? 'background:#3a3a5e;' : ''}">
                    <td>${index + 1}</td>
                    <td>${player.username}</td>
                    <td>${player.highestLevel}</td>
                    <td>${player.totalXp}</td>
                </tr>
            `;
        });
        document.getElementById('levelLeaderboard').innerHTML = levelHTML || '<tr><td colspan="4">No data yet</td></tr>';

        // Get top 10 by XP
        const xpSnapshot = await db.collection('leaderboard')
            .orderBy('totalXp', 'desc')
            .limit(10)
            .get();

        let xpHTML = '';
        xpSnapshot.forEach((doc, index) => {
            const player = doc.data();
            xpHTML += `
                <tr style="${player.username === gameState.currentUser ? 'background:#3a3a5e;' : ''}">
                    <td>${index + 1}</td>
                    <td>${player.username}</td>
                    <td>${player.playerLevel}</td>
                    <td>${player.totalXp}</td>
                </tr>
            `;
        });
        document.getElementById('xpLeaderboard').innerHTML = xpHTML || '<tr><td colspan="4">No data yet</td></tr>';
    } catch (error) {
        console.error('Leaderboard error:', error);
    }
}

// Particle Effects
function createParticles(x, y, isSuccess = true) {
    const particleCount = 15;
    for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = isSuccess ? 'particle' : 'particle particle-fail';
        particle.style.left = x + 'px';
        particle.style.top = y + 'px';
        particle.style.animationDelay = (i * 0.05) + 's';

        // Random direction
        const angle = (Math.PI * 2 * i) / particleCount;
        const velocity = 50 + Math.random() * 50;
        particle.style.setProperty('--tx', Math.cos(angle) * velocity + 'px');
        particle.style.setProperty('--ty', Math.sin(angle) * velocity + 'px');

        document.body.appendChild(particle);

        setTimeout(() => particle.remove(), 1000);
    }
}

// Pause Menu Functions
let isPaused = false;

function togglePause() {
    // Robust check for game screen visibility
    const gameScreen = document.getElementById('gameScreen');
    const mainMenu = document.getElementById('mainMenu');
    const authScreen = document.getElementById('authScreen');

    if (!gameScreen || window.getComputedStyle(gameScreen).display === 'none') return;
    if (mainMenu && window.getComputedStyle(mainMenu).display !== 'none') return;
    if (authScreen && window.getComputedStyle(authScreen).display !== 'none') return;

    isPaused = !isPaused;
    document.getElementById('pauseOverlay').classList.toggle('active', isPaused);
}

function resumeGame() {
    isPaused = false;
    document.getElementById('pauseOverlay').classList.remove('active');
}

// Enhanced keyboard controls
document.addEventListener('keydown', (e) => {
    // ESC for pause
    if (e.key === 'Escape') {
        togglePause();
    }
});

// Level Transition Effect
function showLevelTransition(level) {
    const transition = document.createElement('div');
    transition.className = 'level-transition';
    const text = document.createElement('div');
    text.className = 'level-transition-text';
    text.textContent = `Level ${level}`;
    transition.appendChild(text);
    document.body.appendChild(transition);

    setTimeout(() => transition.remove(), 1500);
}
